#include<GL\glut.h>
#include<iostream>
#include<cmath>
using namespace std;
void setpoint(int x0, int y0, int x, int y) // Dibuja ocho puntos al mismo tiempo (simÃ©trico)
{
	glColor3f(1.0f, 1.0f, 0.0);
	glVertex2f((x0 + x), (y0 + y));
	glVertex2f((x0 + y), (y0 + x));
	glVertex2f((x0 + y), (y0 - x));
	glVertex2f((x0 + x), (y0 - y));
	glVertex2f((x0 - x), (y0 - y));
	glVertex2f((x0 - y), (y0 - x));
	glVertex2f((x0 - y), (y0 + x));
	glVertex2f((x0 - x), (y0 + y));
}
void LineDDA(int x1, int y1, int x2, int y2)
{
	// Encuentra Î”m = max (| Î”x |, | Î”y |) 
	int dm = 0;
	if (abs(x2 - x1) >= abs(y2 - y1)) // abs es una funciÃ³n para valor absoluto
		dm = abs(x2 - x1); // x es la direcciÃ³n de la longitud
	else
		dm = abs(y2 - y1); // y es la direcciÃ³n de la longitud

	// Encuentra âˆ†ğ’™â„âˆ†ğ’, y (âˆ†ğ’š) â„âˆ†ğ’, la direcciÃ³n de la longitud serÃ¡ igual a 1
	float dx = (float)(x2 - x1) / dm;
	float dy = (float)(y2 - y1) / dm;

	// Redondea las coordenadas actuales
	float x = x1 + 0.5;
	float y = y1 + 0.5;

	// Dibuja puntos en un bucle, la direcciÃ³n x aumenta a âˆ†ğ’™â„âˆ†ğ’ y la direcciÃ³n y aumenta a (âˆ†ğ’š) â„âˆ†ğ’
	glColor3f(0.0f, 0.0f, 1.0f); // azul
	glPointSize(5);
	for (int i = 0; i < dm; i++)
	{
		glBegin(GL_POINTS);
		glVertex2i((int)x, (int)y);
		glEnd();
		x += dx;
		y += dy;
	}
}



void Reshape(int w, int h)
{
	glViewport(0, 0, (GLsizei)w, (GLsizei)h); // Definir el tamaÃ±o de la ventana grÃ¡fica
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, (GLdouble)w, 0.0, (GLdouble)h); // Hacer que las coordenadas de la esquina inferior izquierda sean (0, 0) y las coordenadas de la esquina superior derecha sean (w, h)
}

void midpointcircle(int x0, int y0, int r) // MÃ©todo del cÃ­rculo del punto medio
{
	int x = 0;
	int y = r;
	int d = 1 - r; // Para simplificar el algoritmo y deshacerse de los nÃºmeros de coma flotante, el cÃ¡lculo de redondeo se realiza en d, por lo que cambia de 1.25-r a 1-r
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_POLYGON);
	setpoint(x0, y0, x, y);
	while (x < y)
	{
		if (d < 0)
		{
			d += 2 * x + 3;
		}
		else
		{
			d += 2 * (x - y) + 5;
			y--;
		}
		x++;
		setpoint(x0, y0, x, y);
	}
	glEnd();
	glFlush();
}
void ChangeSize(GLsizei w, GLsizei h)
{
	if (h == 0)     h = 1;
	// Establecer el tamaÃ±o de la ventana grÃ¡fica
	glViewport(0, 0, w, h);
	// restablecer el sistema de coordenadas
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	// establece la extensiÃ³n del espacio de recorte
	if (w <= h)
		glOrtho(0.0f, 250.0f, 0.0f, 250.0f * h / w, 1.0, -1.0);
	else
		glOrtho(0.0f, 250.0f * w / h, 0.0f, 250.0f, 1.0, -1.0);
}
void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT);
	int x0 = 100, y0 = 100, r = 60;
	midpointcircle(x0, y0, r);
	glClearColor(1.0, 1.0, 1.0, 1.0); // Color claro, blanco


	glColor3f(1.0f, 0.0f, 0.0f); // Establecer el color, rojo
	glLineWidth(7);
	glBegin(GL_LINES);
	glVertex3f(200.0f, 200.0f, 0.0f);

	glEnd();


	LineDDA(1000, -1000, 100, 100);

	glFlush(); // ActualizaciÃ³n forzada
}
int main(int argc, char* argv[])
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(200, 200);
	glutInitWindowSize(400, 400);
	glutCreateWindow("Practica Circulo");
	glutDisplayFunc(display);
	glutReshapeFunc(Reshape); // Cuando la ventana cambia, que funciÃ³n se usa para redibujar
	glutReshapeFunc(ChangeSize);
	glClearColor(1.0, 1.0, 1.0, 1.0); // Establece el color del fondo de la ventana       
	glutMainLoop();
	return 0;
}
